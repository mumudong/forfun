cpu监控

      系统的 CPU 使用率，不仅包括进程用户态和内核态的运行，还包括中断处理、等待 I/O 以及内核线程等。所以，当你发现系统的 CPU 使用率很高的时候，
      不一定能找到相对应的高 CPU 使用率的进程
      到 CPU 使用率的类型。除了用户 CPU 之外，它还包括
      系统 CPU（比如上下文切换）、
      等待 I/O 的 CPU（比如等待磁盘的响应）以及
      中断 CPU（包括软中断和硬中断）等。
      再看僵尸进程，这是多进程应用很容易碰到的问题。正常情况下，当一个进程创建了子进程后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，
      回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。
      僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退出后，由 init 进程回收后也会消亡。

      top 按1可查看cpu
      每秒1次,总共5次
      pidstat 1 5
      pidstat 1 -p pid号
      mpstat
      uptime， 查看了系统的平均负载

      # 并发 10 个请求测试 Nginx 性能，总共测试 100 个请求
      $ ab -c 10 -n 100 http://192.168.0.10:10000/

      # 并发 5 个请求测试 Nginx 性能，测试10分钟
      $ ab -c 5 -t 600 http://192.168.0.10:10000/

      # -g 开启调用关系分析,分析占用CPU的函数,-p 指定进程号 21515
      $ perf top -g -p 21515

      案例：cpu飙升,top和pidstat查询不到高CPU应用
      方案：观察top中占用CPU的应用,发现处于R状态的进程号不断变化,使用pstree|grep xxx找到父进程
      验证
      # 记录性能事件，等待大约 15 秒后按 Ctrl+C 退出
      $ perf record -g

      # 查看报告
      $ perf report

      execsnoop 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，
      包括进程 PID、父进程 PID、命令行参数以及执行的结果。

     当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，
     你可以发现它们都处于 D 状态，也就是不可中断状态（Uninterruptible Sleep）

     进程状态:
     R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。
     D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），
        一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
     Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，
         但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
     S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。
         当进程等待的事件发生时，它会被唤醒并进入 R 状态。
     I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。
     T/t而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，
       只不过你可以用调试器来跟踪并按需要控制进程的运行。
     另一个是 X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它

     dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。
     # 间隔 1 秒输出 10 组数据
     $ dstat 1 10

     # -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据
     $ pidstat -d -p 4344 1 3

     # 间隔 1 秒输出多组数据 (这里是 20 组)
     $ pidstat -d 1 20

     strace 正是最常用的跟踪进程系统调用的工具。所以，我们从 pidstat 的输出中拿到进程的 PID 号，
     比如 6082，然后在终端中运行 strace 命令，并用 -p 参数指定 PID 号：
     $ strace -p 6082

     你可以用 perf top 看看有没有新发现。再或者，可以像我一样，在终端中运行 perf record，持续一会儿（例如 15 秒），然后按 Ctrl+C 退出，
     再运行 perf report 查看报告：
     直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O

     找到僵尸进程父进程
     # -a 表示输出命令行选项
     # p 表 PID
     # s 表示指定进程的父进程
     $ pstree -aps 3084

     /proc/softirqs 提供了软中断的运行情况；
     /proc/interrupts 提供了硬中断的运行情况。


     sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。
     hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。
     tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。

     开启两个虚拟机,一个部署nginx,另一个使用hping3攻击nginx,nginx服务器会变慢
     # -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 80
     # -i u100 表示每隔 100 微秒发送一个网络帧
     # 注：如果你在实践过程中现象不明显，可以尝试把 100 调小，比如调成 10 甚至 1
     # 这是一个 SYN FLOOD 攻击
     $ hping3 -S -p 80 -i u100 192.168.0.30
     在nginx机器使用top命令,发现cpu使用率不高,占CPU的进程处于软中断
       PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
         7 root      20   0       0      0      0 S   0.3  0.0   0:01.64 ksoftirqd/0
     观察软中断类型
     $ watch -d cat /proc/softirqs
     其中，NET_RX，也就是网络数据包接收软中断的变化速率最快。而其他几种类型的软中断，是保证 Linux 调度、时钟和临界区保护这些正常工作所必需的，
     所以它们有一定的变化倒是正常的。

     # -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据
     $ sar -n DEV 1
     15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil15:03:47
                      eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01

     第一列：表示报告的时间。
     第二列：IFACE 表示网卡。
     第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。
     第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。
     接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，我们稍微计算一下，
     664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是我们通常所说的小包问题。

     # -i eth0 只抓取 eth0 网卡，-n 不解析协议名和主机名
     # tcp port 80 表示只抓取 tcp 协议并且端口号为 80 的网络帧
     $ tcpdump -i eth0 -n tcp port 80
     15:11:32.678966 IP 192.168.0.2.18238 > 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0

     192.168.0.2.18238 > 192.168.0.30.80 ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，
     也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。
     Flags [S] 则表示这是一个 SYN 包。

       $ pidstat -u -t 1
       1      4:24:03      UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
       1      4:24:04        0         -      2472    0.99    8.91    0.00   77.23    9.90     0  |__sysbench
       1      4:24:04        0         -      2473    0.99    8.91    0.00   68.32    9.90     0  |__sysbench
       1      4:24:04        0         -      2474    0.99    7.92    0.00   75.25    8.91     0  |__sysbench
       1      4:24:04        0         -      2475    2.97    6.93    0.00   70.30    9.90     0  |__sysbench
      从这个 pidstat 的输出界面，你可以发现，每个 stress 线程的 %wait 高达 70%，而 CPU 使用率只有不到 10%。换句话说，
      stress 线程大部分时间都消耗在了等待 CPU 上，这也表明，确实是过多的线程在争抢 CPU。

      pidstat 中， %wait 表示进程等待 CPU 的时间百分比。
      top 中 ，iowait% 则表示等待 I/O 的 CPU 时间百分比。
     等待 CPU 的进程已经在 CPU 的就绪队列中，处于运行状态；而等待 I/O 的进程则处于不可中断状态

      perf 这种动态追踪工具，会给系统带来一定的性能损失。
      vmstat、pidstat 这些直接读取 proc 文件系统来获取指标的工具，不会带来性能损失


CPU工具:
    uptime /top
    系统整体CPU使用率:
          vmstat
          mpstat 每个CPU使用率和上下文切换
          top sar
          /proc/stat
    进程CPU使用率:top可按CPU排序
                 pidstat只显示实际使用CPU的进程
                 htop atop不同颜色
    系统上下文切换:vmstat
    进程上下文切换:pidstat -w
    软中断: top  sleep状态
           /proc/softirqs
           mpstat
    硬中断: vmstat
           /proc/interrupts
    网络: dstat
         sar
         tcpdump
    io: dstat
        sar
    cpu个数: lscpu
            /proc/cpuinfo
    事件剖析: perf
            execsnoop


内存：
    oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。
    比如用下面的命令，你就可以把 sshd 进程的 oom_adj 调小为 -16，这样， sshd 进程就不容易被 OOM 杀死。
    echo -16 > /proc/$(pidof sshd)/oom_adj

   free
   tom 然后M
     VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
     RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
     SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等
     %MEM 是进程使用物理内存占系统总内存的百分比。





























































































































































































